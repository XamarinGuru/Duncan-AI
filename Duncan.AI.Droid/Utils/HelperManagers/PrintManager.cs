using System;
using System.Data;
using System.Globalization;
using System.Collections.Generic;
using System.Threading.Tasks;
using Android.Graphics;
using Reino.ClientConfig;
using XMLConfig;
using Duncan.AI.Droid.Common;
using Duncan.AI.Droid.Utils;
using Duncan.AI.Droid.Utils.EditControlManagement.Entities;
using Duncan.AI.Droid.Utils.PrinterSupport;

namespace Duncan.AI.Droid.Utils.HelperManagers
{
    class PrintManager
    {

        private TClientDef clientDef = null;

        public List<IssStruct> IssStructs;
        public List<TableDef> TableDefs;
        public List<TableDef> fCurrentRecordFormattingTableDef;


        /// <summary>
        /// A collection of formatting objects
        /// </summary>
        private List<TFormattingTableInfo> fFormattingTables = new List<TFormattingTableInfo>();




        /// <summary>
        /// Reference to the currently displayed record
        /// </summary>
        private TDataSetRecordInfo fCurrentDataSetRecordInfo;

		static private List<PrintTextInfo> fAllStringsInCurrentTicket;
        //public List<PrintTextInfo> GetPrintTextInfoList()
        //{
        //    return fAllStringsInCurrentTicket;
        //}

        static private List<PCLPrintingClass.PCLStringRow> fAllPCLPrintRowsInCurrentTicket;
        public List<PCLPrintingClass.PCLStringRow> GetPCLPrintRowsList()
        {
            return fAllPCLPrintRowsInCurrentTicket;
        }



        public PrintManager()
            : base()
        {

            clientDef = DroidContext.XmlCfg.GetClientDef();

            IssStructs = DroidContext.XmlCfg.IssStructs;
            TableDefs = DroidContext.XmlCfg.TableDefs;
             
        }

        /// <summary>
        /// Formatting table information 
        /// </summary>
        public class TFormattingTableInfo : Object
        {
            public string fFormatRecordFingerprint = "";

            public TDataSetStructInfo fDataSetStructInfo;
            public int fFormRevNum;
            public int fTableRevNum;
            public string fFormRevName = "";
            public TIssPrnFormRev fCurrentRecordPrintPicRev;
            public TTTable fCurrentRecordFormattingTable;
            public TTableDef fCurrentRecordFormattingTableDef;
            public TTableDefRev fCurrentRecordFormattingTableDefRev;
            public TIssForm fIssueForm;

            //public string fStructDateMask;
            //public string fStructTimeMask;


            /// <summary>
            /// Collection of all displayable data fields
            /// </summary>
            //public List<TClientColumnInfoClass> fDisplayableDataFields = new List<TClientColumnInfoClass>();

            /// <summary>
            /// The list of fields that are actually displayed on the primary record viewing tab
            /// Used to exclude fields from the non-printed fields list
            /// </summary>
            //public List<string> fDisplayedDataFields = new List<string>();


            /// <summary>
            /// Info about the handheld paper for this record, if a print picture is defined
            /// This object is not available until a citation image has been rendered 
            /// </summary>
            //public HandheldPaperInfo fPaperInfo;
        }




        /// <summary>
        /// Encapsulates infomation about a record type in the dataset
        /// </summary>
        public class TDataSetStructInfo : Object
        {
            public DataTable fMainTable;
            ////public DataTable fStatusTable;
            public TIssStruct fIssStruct;
            ////public TCiteStruct fCiteStruct = null;

            ///public TNodeRecordType fNodeRecordType;
            // public TabPage fRecordViewTabPage;
            public string fTabPageCurrentFormatFingerprint = "";

            public bool fCurrentUserHasInquiryRights;
            public bool fCurrentUserHasEditRights;
            public bool fCurrentUserHasVoidReinstateRights;
            public bool fCurrentUserHasNotesRights;

            public bool fNotesSupported;
            public bool fGeoCodeSupported;

            // images for standard records, valid and void
            public int fImageIndexRecordValid;
            public int fImageIndexRecordVoid;
            // ReIssued records are also void, but we show them a distinctly
            public int fImageIndexRecordReIssued;
            // some record types are classified as "warnings" within their data
            public int fImageIndexRecordWarningValid;
            public int fImageIndexRecordWarningVoid;

            /// <summary>
            /// Collection of violation textbox rows. This includes the default row and any autogenerated rows
            /// </summary>
            //public List<TViolationTextBoxRow> fViolationRows;

            /// <summary>
            /// The list of location fields in weighted sorting order. For display order, use fLocationGroupdDisplayOrderFields instead.
            /// </summary>
            public List<string> fLocationGroupSortOrderFields = new List<string>();

            /// <summary>
            /// The list of location fields in display order. For sorting weight use fLocationGroupSortOrderFields instead.
            /// </summary>
            public List<string> fLocationGroupDisplayOrderFields = new List<string>();

            /// <summary>
            /// Control to display the  "extra" fields not found on the print form
            /// </summary>
            //public ListView fNonPrintedFieldListViewControl;

            /// <summary>
            /// Control that contains the location fields for this struct
            /// </summary>
            public Panel fLocationPanel;



            //public CurrencyManager fMainTableCurrencyManager;

            //public List<TSubTableInfo> fSubTables = new List<TSubTableInfo>();

            //public TSubTableInfo FindSubTableInfoByTableName(string iTableName)
            //{
            //    TSubTableFindPredicate loPredicate = new TSubTableFindPredicate(iTableName);
            //    return fSubTables.Find(loPredicate.CompareByTableName);
            //}

            //public TSubTableInfo FindSubTableInfoByTableNameSuffix(string iTableNameSuffix)
            //{
            //    TSubTableFindPredicate loPredicate = new TSubTableFindPredicate(iTableNameSuffix);
            //    return fSubTables.Find(loPredicate.CompareByTableNameSuffix);
            //}

            //public TSubTableInfo FindSubTableInfoByIssStructType(Type iIssStructType)
            //{
            //    TSubTableFindPredicate loPredicate = new TSubTableFindPredicate(iIssStructType);
            //    return fSubTables.Find(loPredicate.CompareByIssStructType);
            //}

        }

        public class TFormatInfoFingerprintFindPredicate : object
        {
            private string fCompareFingerprint;

            public TFormatInfoFingerprintFindPredicate(string iCompareFingerprint)
            {
                fCompareFingerprint = iCompareFingerprint;
            }

            public bool CompareByFingerprint(TFormattingTableInfo iFormatTableObject)
            {
                return iFormatTableObject.fFormatRecordFingerprint.Equals(fCompareFingerprint);
            }
        }


        // carried in the tag of the treeview node record
        public class TDataSetRecordInfo : Object
        {
            public TDataSetStructInfo fDataSetStructInfo;
            public int fDataViewRowPosition;
            public DataRow fDataRow;
            public TFormattingTableInfo fFormatInfo;
            public string fFormattedRecordDescription;
            public string fFormattedRecordIssueNo = ""; //init to empty string, not all records will have a value
            //public TVoidStatus fVoidStatus;
            public bool fIsWarning;
            // public TMapPointLocationInfo fMapLocationInfo = new TMapPointLocationInfo();
        }

        /// <summary>
        /// Return the issueance form for passed TIssStruct
        /// </summary>
        /// <param name="iIssStruct"></param>
        /// <returns></returns>
        private TIssForm GetIssueFormForStruct(TIssStruct iIssStruct)
        {
            // Look through the forms defined in the passed TCiteStruct
            foreach (TTForm loForm in iIssStruct.Forms)
            {
                // Is this the issuance form?
                if (loForm.Name.ToUpper().StartsWith("ISSUE") == true)
                {
                    return loForm as TIssForm;
                }


                //if (loForm is TIssForm)
                //{
                //    return loForm as TIssForm;
                //}
            }
            // If we get this far, we couldn't find the target 
            return null;
        }


        public IssStruct GetStruct(String structType, String structName)
        {
            return this.IssStructs.Find(x => x != null && x.Type == structType && x.Name == structName);
        }


        private TDataSetStructInfo InitCurrentDatasetStructInfo(TIssStruct loIssStruct, DataTable iMainDataTable)
        {

            // look through our dataset and identify the tables and match them with their TIssStructs
            //foreach (DataTable loTable in dsCurrentRecordDataSet.Tables)
            {
                // figure out which struct this belongs to
                //TIssStruct loIssStruct = FindStructForTableName(loTable.TableName);

                // no match? 
                //if (loIssStruct == null) { continue; }

                // is this struct one of the excluded types?
                //if (fNonPrimaryStructTypes.Contains(loIssStruct.GetType())) { continue; }

                // special exclusion - STATUS tables are excluded as well, but they don't have struct type
                //if (loTable.TableName.EndsWith(DBConstants.cnStatusTableNameSuffix)) { continue; }

                // translink tables as well
               // if (loTable.TableName.EndsWith(DBConstants.cnTransactionLinkTableNameSuffix)) { continue; }


                // create a record of info about this struct
                TDataSetStructInfo loDataSetStructInfo = new TDataSetStructInfo();
                loDataSetStructInfo.fIssStruct = loIssStruct;

                // locate each of the (possible) tables in the dataset
                loDataSetStructInfo.fMainTable = iMainDataTable; // dsCurrentRecordDataSet.Tables[dsCurrentRecordDataSet.Tables.IndexOf(loIssStruct.MainTable.Name)];

                // we only count the records in the main table as part of the match count
                //fTotalMatchingRecords += loDataSetStructInfo.fMainTable.Rows.Count;


                /*
                // now we'll check the dataset and find any tables that are subtables of ours
                foreach (DataTable loSubTable in dsCurrentRecordDataSet.Tables)
                {
                    // some special checks
                    if (AddSpecialtySubTableIfSuffixMatches(loDataSetStructInfo, loSubTable, DBConstants.cnTransactionLinkTableNameSuffix))
                    {
                        // found the transaction link table, move along
                        continue;
                    }

                    if (AddSpecialtySubTableIfSuffixMatches(loDataSetStructInfo, loSubTable, DBConstants.cnStatusHistoryVirtualTableNameSuffix))
                    {
                        // found the status history table, move along
                        continue;
                    }

                    if (AddSpecialtySubTableIfSuffixMatches(loDataSetStructInfo, loSubTable, DBConstants.cnExportHistoryVirtualTableNameSuffix))
                    {
                        // found the export history table, move along
                        continue;
                    }

                    if (AddSpecialtySubTableIfSuffixMatches(loDataSetStructInfo, loSubTable, DBConstants.cnNSWStatusVirtualTableNameSuffix))
                    {
                        // found the NSW Status history table, move along
                        continue;
                    }

                    // figure out which struct this belongs to
                    TIssStruct loSubIssStruct = FindStructForTableName(loSubTable.TableName);

                    // no match? 
                    if (loSubIssStruct == null) { continue; }

                    // does this struct claim to be belong to the current main?
                    if (loSubIssStruct is TCiteDetailStruct)
                    {

                        if (((TCiteDetailStruct)loSubIssStruct).ParentStruct.Equals(loIssStruct.Name))
                        {
                            // add it to this one
                            AddSubTableInfo(loDataSetStructInfo, loSubTable, loSubIssStruct, "");

                            // is this a notes table?
                            if (loSubIssStruct.GetType() == typeof(TNotesStruct))
                            {
                                // we add some extra colums to the notes tables
                                AddPreRenderedColumnsToNotesTable(loSubTable);
                            }

                        }
                    }

                }
                */

                // determine the "universal" record type from this table, for naming/glyph usage
                //loDataSetStructInfo.fNodeRecordType = GetRecordTypeForTable(loIssStruct.MainTable.Name);

                // set flag to decide if location mapping is supported
                //fMappingSupportedByCurrentDataSet = (fMappingSupportedByCurrentDataSet || (fNodeRecordTypeSupportsLocationMapping.Contains(loDataSetStructInfo.fNodeRecordType)));

                // setup so values according to the data type
                //UpdateTabPageAndTreeViewImageIndexesForNodeType(loDataSetStructInfo);

                // get a reference to the list view control we'll be using
                //loDataSetStructInfo.fNonPrintedFieldListViewControl = GetNonPrintedFieldListViewForNodeType(loDataSetStructInfo.fNodeRecordType);
                // set it up
                //InitializeNonPrintedFieldsListViewControl(loDataSetStructInfo.fNonPrintedFieldListViewControl);

                // get a reference to the location panel
                //loDataSetStructInfo.fLocationPanel = GetLocationPanelForNodeType(loDataSetStructInfo.fNodeRecordType);


                // update the main tab to display the record number, if one has been defined
                //if (loDataSetStructInfo.fRecordViewTabPage != null)
                //{
                //    loDataSetStructInfo.fRecordViewTabPage.Text = loIssStruct.ObjDisplayName + cnTabRecordNameSuffix;
               // }


                // determine what our location fields are
                //DetermineLocationFieldsForStructInfo(loDataSetStructInfo);

                // initalize the currency manager references 
                //InitializeCurrencyManagersForStruct(loDataSetStructInfo);

                /*
                // do this now so we have the info to do the binding 
                // even through these can change per current row, we need to
                // have something to start with for the binding
                ResolveFormattingTableReferencesForDataRow(loDataSetStructInfo);
                */

                // get the current user rights to this struct
                //UpdateUsageFeaturesAndAccessRightsForStruct(loDataSetStructInfo);

                // add this one to the list
                //fDataSetStructs.Add(loDataSetStructInfo);

                return loDataSetStructInfo;
            }
        
        }

        public Bitmap PrintPicture(String structName, String issueNum, DateTime issueDate)
        {
            TIssPrnFormRev loPrintPic = null;
            String structType = "TCiteStruct";
            structName = "PARKING";

            
            IssStruct issStruct = GetStruct(structType, structName);

            var listSupport = new ListSupport( );
            //var ticketValues = listSupport.GetAllFromTableWithColumnValue("PARKING", "ISSUENO", issueNum);
            var ticketValues = listSupport.GetAllFromTableWithColumnValue(structName, Constants.ISSUENO_COLUMN, issueNum);
            if (ticketValues != null && ticketValues.Rows.Count > 0)
            {
                DataRow oneDataRow = ticketValues.Rows[0];

                // figure out what this is
                TDataSetStructInfo dsStructInfo = InitCurrentDatasetStructInfo(issStruct._TIssStruct, oneDataRow.Table);


                // create a record of this row
                TDataSetRecordInfo loRecordInfo = new TDataSetRecordInfo();
                loRecordInfo.fDataSetStructInfo = dsStructInfo;
                loRecordInfo.fDataViewRowPosition = 0; // loRowNum;
                loRecordInfo.fDataRow = oneDataRow; //  loRow;
                //loRecordInfo.fVoidStatus = GetVoidStatusForRow(loRecordInfo.fDataSetStructInfo, loRow);
                //loRecordInfo.fIsWarning = GetWarningStatusForRow(loRow);

                //loRecordInfo.fFormatInfo = FindFormatInfoInCrossReferenceList(loRow);
                loRecordInfo.fFormatInfo = GenerateFormatInfoForDataRow(dsStructInfo, oneDataRow);
                
                fCurrentDataSetRecordInfo = loRecordInfo;


                // fill it up with the raw data from the db
                FillFormattingTableWithCurrentRecord(oneDataRow);

                // now pull it back out formatted
                PullPrintDataFromFormattingTable();

                //fCurrentDataSetRecordInfo.fDataSetStructInfo.{

                loPrintPic = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordPrintPicRev;


                // copy these locallly so we can override as needed
                int loHeight = loPrintPic.Height;
                int loWidth = loPrintPic.Width;


                
                // is this an alternate layout definition?
                string loAlternatePrintPicture = TTRegistry.glRegistry.GetRegistryValue(TTRegistry.regSECTION_ISSUE_AP,
                                                                                      TTRegistry.regPRINTER_ALTERNATE_3IN_TEXT_PICTURE,
                                                                                      TTRegistry.regPRINTER_ALTERNATE_3IN_TEXT_PICTURE_DEFAULT);

                if (fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordPrintPicRev.Name.Equals( loAlternatePrintPicture, StringComparison.CurrentCultureIgnoreCase) == true)
                {
                    // we borrowed the 4in layout to define the 2T text picture - override to force 3in width for preview screen
                    loWidth = 576;
                }
    
                //// is this a 2T text layout?
                //if ( DroidContext.gPrinterSelected == PrintersSupported.Printer_TwoTechnologiesN5Class )
                //{
                //    // we borrowed the 4in layout to define the 2T text picture - override to force 3in width for preview screen
                //    loWidth = 576;
                //}



                loPrintPic.PrepareForPrint();


                // use the local values
                //loPrintPic.Series3CE_ClearPrintCanvas(loPrintPic.Height, loPrintPic.Width);
                loPrintPic.Series3CE_ClearPrintCanvas(loHeight, loWidth);

                loPrintPic.PaintDescendants();

				//Get list of all text objects in the current ticket
                fAllStringsInCurrentTicket = loPrintPic.GetAllStringsInCurrentTicket();


                PCLPrintingClass pclPrintingObject = new PCLPrintingClass();
                fAllPCLPrintRowsInCurrentTicket = pclPrintingObject.ConvertPrintTextIntoPCLObjects(fAllStringsInCurrentTicket);


                //return (loPrintPic.WriteBitmapData());
                return loPrintPic.GetOffscreenBitmapWin32();

            }
            else
            {
                return null;
            }

        }




        /// <summary>
        /// Fills the formatting table with the current record from the dataset
        /// so that the data can be pulled out using the config defined formats
        /// </summary>
        private void FillFormattingTableWithCurrentRecord(DataRow iCurrentRecordDataRow)
        {

            string loFieldValueStr;
            string loSourceFieldNameStr;
            DateTime loFieldValueDT;
            //DataRowView dvSourceRowView = null;



            // most fields will be located in the main table, but some will be found in subtables
            bool loFieldLocated = false;


            // loop through the fields in the table revision, and populate the table
            fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.ClearFieldValues();
            foreach (TTableFldDef loFld in fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTableDefRev.Fields)
            {

                // assume we'll find the target field in the main table
                loFieldLocated = false;

                // start with the actual name
                loSourceFieldNameStr = loFld.Name;

                // in the main table?
                if ((fCurrentDataSetRecordInfo.fDataSetStructInfo.fMainTable.Columns.IndexOf(loSourceFieldNameStr)) != -1)
                {
                    // defense against funky databases - make sure this column wasn't created
                    // in error and the data is actually moved to a detail table
                    if (loFld.IsRedefinedInDetailTable == false)
                    {
                        // get the current datarow from the main table's currency manager
                        //iCurrentRecordDataRow = (DataRowView)fCurrentDataSetRecordInfo.fDataSetStructInfo.fMainTableCurrencyManager.Current;
                        loFieldLocated = true;
                    }

                }

                // find it in the main table?
                if (loFieldLocated == false)
                {
                    // it maybe in a detail table. Since detail tables can have multiple records,
                    // we're prepare for that. Start by assuming its the default row;
                    int loDetailSubTablePosition = 0;

                    // is this a "special" field?
                    if (loFld.TableNdx > 0)
                    {
                        // extract the occurence number from the end of the field name
                        int loOccurNoPos = loFld.Name.LastIndexOf('_');
                        if (loOccurNoPos != -1)
                        {
                            string loOccurNoStr = loFld.Name.Substring(loOccurNoPos + 1);
                            try
                            {
                                // the target is the "root" field name, without the occur no suffix
                                loSourceFieldNameStr = loFld.Name.Substring(0, loOccurNoPos);
                                // and the occurno suffix is its position in the list
                                loDetailSubTablePosition = Convert.ToInt32(loOccurNoStr);
                            }
                            catch
                            {
                                // somthing wasn't right - force a bad name so we'll get no data
                                loSourceFieldNameStr = loFld.Name + " is not defined.";
                            }
                        }


                        /*
                        // wasn't in the main table. look through the sub tables
                        foreach (TSubTableInfo loCheckTableInfo in fCurrentDataSetRecordInfo.fDataSetStructInfo.fSubTables)
                        {
                            // now we've stripped off any suffix... is it in this subtable?
                            if ((loCheckTableInfo.fDataTable.Columns.IndexOf(loSourceFieldNameStr)) != -1)
                            {
                                // if a sub table is the source, then we need to 
                                // use ITS currency manager for the child relation row, if we can...
                                if ((loCheckTableInfo.fSubTableCurrencyManager.Count > 0) && (loDetailSubTablePosition < loCheckTableInfo.fSubTableCurrencyManager.Count))
                                {
                                    // reference the row
                                    dvSourceRowView = (DataRowView)loCheckTableInfo.fSubTableCurrencyManager.List[loDetailSubTablePosition];
                                    // we got it
                                    loFieldLocated = true;
                                    break;
                                }

                            }
                        }
                         * */
                    }

                }

                // find one?
                if (loFieldLocated == false)
                {
                    // should always be able to locate the field, unless the db and the config aren't matched
                    continue;
                }



                try
                {

                    // default to 
                    string loSQLiteColumnReadDataMask = loFld.Mask;

                    TPrnDataElementFindPredicate loFindPred = new TPrnDataElementFindPredicate(loFld.Name);
                    TWinBasePrnData loPrnData = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordPrintPicRev.AllPrnDataElements.Find(loFindPred.CompareByElementName);
                    if (loPrnData == null)
                    {
                        loPrnData = new TWinBasePrnData();
                        loPrnData.Name = loFld.Name;
                    }


                    // must locate the fieldno in the table revision; if we ask via the tabledef we always get the highest
                    int loFieldNo = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.fTableDef.GetFldNo(loPrnData.Name);

                    //loFieldNo = dsStructInfo.fCurrentRecordFormattingTableDefRev.Fields.FindIndex(new TObjBasePredicate(loPrnData.Name).CompareByName);

                    if (loFieldNo != -1)
                    {
                        TTableFldDef loOneField = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTableDefRev.Fields[loFieldNo];
                        //string loDataMask;
                        // translate it back to AutoISSUE style for accurate display
                        // Always use the MaskForHH whenever possible as it will handle date and time masks
                        // properly. (The regular Mask property is not reliable because it has been subjected
                        // to various translations)
                        switch (loFld.EditDataType)
                        {
                            case TTableFldDef.TEditDataType.tftDate:
                                {
                                    /*
                                    if (loPrnData.MaskForHH != "")
                                        loSQLiteColumnReadDataMask = loPrnData.MaskForHH;
                                    else
                                        loSQLiteColumnReadDataMask = AutoISSUE.DBConstants.GetAutoISSUEMaskForDotNetMask_Date(loPrnData.Mask);

                                    loSQLiteColumnReadDataMask = AutoISSUE.DBConstants.GetDotNetMaskForAutoISSUEMask_Date(loSQLiteColumnReadDataMask);
                                     */

                                    // this is how it SHOULD be, we have to fix all the writes to use this too
                                    loSQLiteColumnReadDataMask = Constants.DB_SQLITE_DATEONLY_TYPE_FIXED_STORAGE_FORMAT_MASK;
                                    break;
                                }

                            case TTableFldDef.TEditDataType.tftTime:
                                {
                                    /*
                                    if (loPrnData.MaskForHH != "")
                                        loSQLiteColumnReadDataMask = loPrnData.MaskForHH;
                                    else
                                        loSQLiteColumnReadDataMask = AutoISSUE.DBConstants.GetAutoISSUEMaskForDotNetMask_Time(loPrnData.Mask);

                                    loSQLiteColumnReadDataMask = AutoISSUE.DBConstants.GetDotNetMaskForAutoISSUEMask_Time(loSQLiteColumnReadDataMask);
                                     */

                                    // this is how it SHOULD be, we have to fix all the writes to use this too
                                    loSQLiteColumnReadDataMask = Constants.DB_SQLITE_TIMEONLY_TYPE_FIXED_STORAGE_FORMAT_MASK;
                                    break;
                                }
                            default:
                                {

                                    // we dont want to override?? 
                                    /*
                                    if (loPrnData.MaskForHH != "")
                                        loDataMask = loPrnData.MaskForHH;
                                    else
                                        loDataMask = loPrnData.Mask;
                                     */
                                    break;
                                    
                                }
                        }
                    }


                    // get the value from the dataset in the appropriate format
                    switch (loFld.EditDataType)
                    {
                        /* AJW - these are all string types in SQLite.... 
                         * */

                        case TTableFldDef.TEditDataType.tftDate:
                            {
                                if (iCurrentRecordDataRow.IsNull(loSourceFieldNameStr) == false)
                                {
                                    // get the value from the datarow
                                    //loFieldValueDT = (DateTime)iCurrentRecordDataRow[loSourceFieldNameStr];

                                    // get the string value from the datarow
                                    string loDateTimeTypeAsString = iCurrentRecordDataRow[loSourceFieldNameStr].ToString().Trim();

                                    if (loDateTimeTypeAsString.Length > 0)
                                    {
                                        try
                                        {
                                            // convert from SQLite formatted date string to a DateTime obj
                                            loFieldValueDT = DateTime.ParseExact(loDateTimeTypeAsString, loSQLiteColumnReadDataMask, CultureInfo.CurrentCulture);

                                            // and now convert it into the format the formatting table is expecting
                                            loFieldValueStr = loFieldValueDT.ToString(ReinoTablesConst.DATE_TYPE_DATAMASK);
                                        }
                                        catch (Exception exp)
                                        {
                                            Console.WriteLine("An error occurred during date extraction. " + exp.Message);
                                            loFieldValueStr = "";
                                        }
                                    }
                                    else
                                    {
                                        loFieldValueStr = ""; // unparsable value
                                    }


                                    // the "(select)" should't be stored or printed
                                    //if (loFieldValueStr == Constants.SPINNER_DEFAULT)
                                    //    loFieldValueStr = "";    


                                    // set it in the field
                                    fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, ReinoTablesConst.DATE_TYPE_DATAMASK, loFieldValueStr);
                                }
                                break;
                            }

                        case TTableFldDef.TEditDataType.tftTime:
                            {
                                if (iCurrentRecordDataRow.IsNull(loSourceFieldNameStr) == false)
                                {
                                    // get the value from the datarow
                                    //loFieldValueDT = (DateTime)iCurrentRecordDataRow[loSourceFieldNameStr];

                                    // get the string value from the datarow
                                    string loDateTimeTypeAsString = iCurrentRecordDataRow[loSourceFieldNameStr].ToString().Trim();

                                   
                                    if (loDateTimeTypeAsString.Length > 0)
                                    {
                                        try
                                        {
                                            // convert from SQLite formatted date string to a DateTime obj
                                            loFieldValueDT = DateTime.ParseExact(loDateTimeTypeAsString, loSQLiteColumnReadDataMask, CultureInfo.CurrentCulture);

                                            // and now convert it into the format the formatting table is expecting
                                            loFieldValueStr = loFieldValueDT.ToString(ReinoTablesConst.TIME_TYPE_DATAMASK);
                                        }
                                        catch (Exception exp)
                                        {
                                            Console.WriteLine("An error occurred during date extraction. " + exp.Message);
                                            loFieldValueStr = "";
                                        }
                                    }
                                    else
                                    {
                                        loFieldValueStr = ""; // unparsable value
                                    }


                                    //// the "(select)" should't be stored or printed
                                    //if (loFieldValueStr == Constants.SPINNER_DEFAULT)
                                    //    loFieldValueStr = "";    

                                    // set it in the field
                                    fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, ReinoTablesConst.TIME_TYPE_DATAMASK, loFieldValueStr);
                                }
                                break;
                            }
                        case TTableFldDef.TEditDataType.tftInteger:
                            {
                                // get the value from the datarow
                                loFieldValueStr = iCurrentRecordDataRow[loSourceFieldNameStr].ToString();

                                //// the "(select)" should't be stored or printed
                                //if (loFieldValueStr == Constants.SPINNER_DEFAULT)
                                //    loFieldValueStr = "";    

                                // set it in the field
                                fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, loSQLiteColumnReadDataMask, loFieldValueStr);
                                break;
                            }
                        case TTableFldDef.TEditDataType.tftReal:
                            {
                                // get the value from the datarow
                                loFieldValueStr = iCurrentRecordDataRow[loSourceFieldNameStr].ToString();

                                // the "(select)" should't be stored or printed
                                //if (loFieldValueStr == Constants.SPINNER_DEFAULT)
                                //    loFieldValueStr = "";    


                                // NOTE: this is a KLUGE fix - 
                                // the field mask usually isn't set for real fields,
                                // and when its not, the SetForattedFieldData won't format it
                                // This usually isn't a problem because the value is coming from an edit box which
                                // already has formatted it. For us, we're getting the value
                                // from a dataset, raw and unformatted. So we need to force
                                // a format if there isn't one defined so that we don't
                                // end up storing "35" and read back "0.35" when what we wanted was "35.00"
                                if (loFld.Mask.Length == 0)
                                {
                                    // no mask defined, we'll make an assumption and give it one that forces decimal places
                                    if (iCurrentRecordDataRow[loSourceFieldNameStr] != System.DBNull.Value)
                                    {
                                        loFieldValueStr += "00";
                                    }

                                    fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, "8", loFieldValueStr);
                                }
                                else
                                {
                                    // set it in the field, using the defined mask
                                    fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, loSQLiteColumnReadDataMask, loFieldValueStr);
                                }
                                break;
                            }


                        // default case is also the string
                        default: //TTableFldDef.TEditDataType.tftString :
                            {
                                // get the value from the datarow
                                loFieldValueStr = iCurrentRecordDataRow[loSourceFieldNameStr].ToString();

                                // the "(select)" should't be stored or printed
                                //if (loFieldValueStr == Constants.SPINNER_DEFAULT)
                                //    loFieldValueStr = "";    


                                // set it in the field
                                fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.SetFormattedFieldData(loFld.Name, loSQLiteColumnReadDataMask, loFieldValueStr);
                                break;
                            }
                    }

                }
                catch (Exception exp)
                {
                    // if its not in the dataset... ??
                    Console.WriteLine("An error occurred during data formatting. " + exp.Message);
                }

            }


        }
        


        private void PullPrintDataFromFormattingTable()
        {

             // get the data back out of the formatting table... formatted as required for printing
            TWinBasePrnData loPrnData;
            short loNdx;
            int loFieldNo;
            TTableFldDef loTableField = null;
            for (loNdx = 0; loNdx < fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordPrintPicRev.AllPrnDataElements.Count; loNdx++)
            {
                loPrnData = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordPrintPicRev.AllPrnDataElements[loNdx];
                if (loPrnData == null)
                    continue;
                try
                {
                    // must locate the fieldno in the table revision; if we ask via the tabledef we always get the highest
                    loFieldNo = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.fTableDef.GetFldNo(loPrnData.Name);
                    //loFieldNo = dsStructInfo.fCurrentRecordFormattingTableDefRev.Fields.FindIndex(new TObjBasePredicate(loPrnData.Name).CompareByName);

                    if (loFieldNo != -1)
                    {
                        TTableFldDef loOneField = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTableDefRev.Fields[loFieldNo];
                        string loDataMask;

                        // translate it back to AutoISSUE style for accurate display
                        // Always use the MaskForHH whenever possible as it will handle date and time masks
                        // properly. (The regular Mask property is not reliable because it has been subjected
                        // to various translations)
                        switch (loOneField.EditDataType)
                        {
                            case TTableFldDef.TEditDataType.tftDate:
                                {
                                    if (loPrnData.MaskForHH != "")
                                        loDataMask = loPrnData.MaskForHH;
                                    else 
                                        loDataMask = AutoISSUE.DBConstants.GetAutoISSUEMaskForDotNetMask_Date(loPrnData.Mask);
                                    break;
                                }
                            case TTableFldDef.TEditDataType.tftTime:
                                {
                                    if (loPrnData.MaskForHH != "")
                                        loDataMask = loPrnData.MaskForHH;
                                    else 
                                        loDataMask = AutoISSUE.DBConstants.GetAutoISSUEMaskForDotNetMask_Time(loPrnData.Mask);
                                    break;
                                }
                            default:
                                {
                                    if (loPrnData.MaskForHH != "")
                                        loDataMask = loPrnData.MaskForHH;
                                    else 
                                        loDataMask = loPrnData.Mask;
                                    break;
                                }
                        }


#if __ANDROID__
                        // AJW TODO - this should probably be nixed when stored in the DB
                        string loPrintDataString = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.GetFormattedFieldData(loFieldNo, loDataMask);

                        // remove abbrev descriptions when present
                        int loPos = loPrintDataString.IndexOf(Constants.LIST_ITEM_DESCRIPTION_SEPARATOR);
                        // has to be beyond the first char
                        if (loPos > 0 )
                        {
                            // keep everything up to the space preceeding the seperator char
                            loPrintDataString = loPrintDataString.Substring(0, loPos - 1);
                        }

                        loPrnData.TextBuf = loPrintDataString;
#else
                        loPrnData.TextBuf = fCurrentDataSetRecordInfo.fFormatInfo.fCurrentRecordFormattingTable.GetFormattedFieldData(loFieldNo, loDataMask);
#endif

                        /*
                        // we need to ask the for the data based on the data's revision, so we do it this way
                        // because if we ask for it using GetFormattedFieldData it always references the HighestTableRev
                        this gives us double-printed OnActivated some FieldAccessException (colors!!)

                        string loFormattedFieldData = "";
                        loOneField.ConvertFromStoreFormat(dsStructInfo.fCurrentRecordFormattingTable, loFieldNo, loDataMask, ref loFormattedFieldData);
                        loPrnData.TextBuf = loFormattedFieldData;
                         */
                    }

                    // 2009.09.01 JLA - Special case is TWinPrnImage which lets us embed an image from the notes table into the ticket image
                    if (loPrnData is TWinPrnImage)
                    {
                     //   GetDataForEmbeddedImage((loPrnData as TWinPrnImage), dsStructInfo.fIssStruct);
                    }
                }
                catch
                {
                    // if its not in the dataset... ??
                }

            }

}

        ////////////////////

        /// <summary>
        /// Universal method of producing a fingerprint to identify a formatting object
        /// </summary>
        /// <returns></returns>
        private string GenerateFormattingFingerprint(string iDataTableName, int iTableRevNum, string iFormRevName, int iFormRevNum)
        {
            return iDataTableName.Trim() + "-" + iTableRevNum.ToString() + "-" + iFormRevName.Trim() + iFormRevNum.ToString();
        }

        /// <summary>
        /// Determine the formatting fingerprint for passed row
        /// </summary>
        /// <param name="dsDataSetStructInfo"></param>
        /// <param name="iRow"></param>
        /// <returns></returns>
        private string GetFormattingTableFingerprintForDataRow(TDataSetStructInfo dsDataSetStructInfo, DataRow iRow, ref int ioTableRevNum, ref string ioFormRevName, ref int ioFormRevNum)
        {
            // extract the form revision number
            ioFormRevNum = 0;
            try
            {
                if (iRow.IsNull(AutoISSUE.DBConstants.sqlFormRevisionNumberStr) == false)
                {
                    ioFormRevNum = int.Parse(iRow[AutoISSUE.DBConstants.sqlFormRevisionNumberStr].ToString());
                }
            }
            catch (Exception)
            {
                ioFormRevNum = 0;
            }


            // and the table revision number
            ioTableRevNum = 0;
            try
            {
                if (iRow.IsNull(AutoISSUE.DBConstants.sqlTableRevisionNumberStr) == false)
                {
                    ioTableRevNum = int.Parse(iRow[AutoISSUE.DBConstants.sqlTableRevisionNumberStr].ToString());
                }
            }
            catch (Exception)
            {
                ioTableRevNum = 0;
            }


            // get the form revision name 
            ioFormRevName = "";
            try
            {
                ioFormRevName = iRow[AutoISSUE.DBConstants.sqlFormRevisionNameStr].ToString();
            }
            catch (Exception)
            {
                ioFormRevName = "";
            }



            // generate a "fingerprint" for this formatting info so we can match it up for other records
            return GenerateFormattingFingerprint(iRow.Table.TableName, ioTableRevNum, ioFormRevName, ioFormRevNum);
        }


        /// <summary>
        /// Resolve internal formatting table references based on the FORMREV for passed row
        /// The passed row should be from the MAIN TABLE of the record of interest
        /// To optimize for speed, we don't actually fill the formatting table with
        /// any data until/unless the click on the cite print picture tab
        /// </summary>
        private TFormattingTableInfo ConstructFormattingTableInfo(TDataSetStructInfo dsDataSetStructInfo, string iDataTableName, int iTableRevNum, string iFormRevName, int iFormRevNum)
        {
            // the formatting info is the table, form, and print picture that match the data revision
            TFormattingTableInfo loFormatInfo = new TFormattingTableInfo();
            loFormatInfo.fDataSetStructInfo = dsDataSetStructInfo;
            loFormatInfo.fFormRevName = iFormRevName;
            loFormatInfo.fFormRevNum = iFormRevNum;
            loFormatInfo.fTableRevNum = iTableRevNum;


            // if its valid, resolve the references
            if (loFormatInfo.fTableRevNum <= dsDataSetStructInfo.fIssStruct.MainTable.Revisions.Count)
            {
                // can't count on the serialization to preserve the order... so we have to find it specifically
                foreach (TTableDefRev loDefRev in dsDataSetStructInfo.fIssStruct.MainTable.Revisions)
                {
                    //is this the revision we need?
                    //if (loDefRev.Revision == loFormatInfo.fTableRevNum)   there should only be ONE in the handheld xml
                    {
                        // we must make our own copy because it must have exactly one revision
                        // this way we will have only a single revision in our private def because
                        // the virtual field code embed references to the highest table revision, which we are not
                        // plus we'll have it here for thread safe access/usage
                        loFormatInfo.fCurrentRecordFormattingTableDef = new TTableDef();
                        loFormatInfo.fCurrentRecordFormattingTableDefRev = new TTableDefRev();
                        foreach (TTableFldDef oneField in loDefRev.Fields)
                        {
                            loFormatInfo.fCurrentRecordFormattingTableDefRev.Fields.Add(oneField);
                        }
                        loFormatInfo.fCurrentRecordFormattingTableDef.Revisions.Add(loFormatInfo.fCurrentRecordFormattingTableDefRev);

                        // now the table
                        loFormatInfo.fCurrentRecordFormattingTable = new TTTable();
                        loFormatInfo.fCurrentRecordFormattingTable.fTableDef = loFormatInfo.fCurrentRecordFormattingTableDef;
                        break;
                    }
                }
            }
            else
            {
                // DEBUG: 2011-11-16 Alvin encountered a problem where TabRev records have a higher value than the latest revision, causing the app to crash
                // If we get here then the table revision isn't valid, so I guess the best we can do is treat it as if it were the 
                // same revision number as the latest we know about.
                TTableDefRev loDefRev = dsDataSetStructInfo.fIssStruct.MainTable.HighTableRevision;

                // we must make our own copy because it must have exactly one revision
                // this way we will have only a single revision in our private def because
                // the virtual field code embed references to the highest table revision, which we are not
                // plus we'll have it here for thread safe access/usage
                loFormatInfo.fCurrentRecordFormattingTableDef = new TTableDef();
                loFormatInfo.fCurrentRecordFormattingTableDefRev = new TTableDefRev();
                foreach (TTableFldDef oneField in loDefRev.Fields)
                {
                    loFormatInfo.fCurrentRecordFormattingTableDefRev.Fields.Add(oneField);
                }
                loFormatInfo.fCurrentRecordFormattingTableDef.Revisions.Add(loFormatInfo.fCurrentRecordFormattingTableDefRev);

                // now the table
                loFormatInfo.fCurrentRecordFormattingTable = new TTTable();
                loFormatInfo.fCurrentRecordFormattingTable.fTableDef = loFormatInfo.fCurrentRecordFormattingTableDef;
            }


            // Get the Issuance form for the passed structure
            loFormatInfo.fIssueForm = GetIssueFormForStruct(dsDataSetStructInfo.fIssStruct);

            // if we found an issue form, we need to set parents for the printpicture
            if (loFormatInfo.fIssueForm != null)
            {
                if (loFormatInfo.fIssueForm.PrintPictureList.Count > 0)
                {
                    foreach (TIssPrnForm loPrintPic in loFormatInfo.fIssueForm.PrintPictureList)
                    {
                        foreach (TIssPrnFormRev loPrintPicRev in loPrintPic.Revisions)
                        {
                            // If the list is empty, maybe it hasn't been populated yet
                            if (loPrintPicRev.AllPrnDataElements.Count == 0)
                            {
                                loPrintPicRev.AllPrnDataElements.Clear();
                                loPrintPicRev.ResolveObjectReferences(null, loPrintPicRev);
                                loPrintPicRev.AddDataElementsToList(loPrintPicRev.AllPrnDataElements);
                            }
                        }
                    }
                }
            }


            // get the print picture revision for this record, if there is one
            if (loFormatInfo.fIssueForm != null)
            {
                TIssPrnForm loPrintPicture = null;

                // we'd like to just locate it by name
                if (loFormatInfo.fFormRevName.Length > 0)
                {
                    TObjBasePredicate loFindFormPredicate = new TObjBasePredicate(loFormatInfo.fFormRevName);
                    loPrintPicture = loFormatInfo.fIssueForm.PrintPictureList.Find(loFindFormPredicate.CompareByName_CaseInsensitive);
                }

                // find the print picture? if not, employ a safety fallback,
                // in case printpicture name is not populated in the data
                if (loPrintPicture == null)
                {
                    if (loFormatInfo.fIssueForm.PrintPictureList.Count > 0)
                    {
                        // default to the only print picture
                        loPrintPicture = loFormatInfo.fIssueForm.PrintPictureList[0];
                    }
                }


                // we have a print picture, now find the revision number
                if (loPrintPicture != null)
                {
                    // iterate to find the matching revision, serialization doesn't preserve collection order (?)
                    foreach (TIssPrnFormRev loPrintRev in loPrintPicture.Revisions)
                    {
                        if (loPrintRev.Revision == loFormatInfo.fFormRevNum)
                        {
                            loFormatInfo.fCurrentRecordPrintPicRev = loPrintRev;
                            break;
                        }
                    }
                }


                // android extension - did we find the print picture revision?
                if (loFormatInfo.fCurrentRecordPrintPicRev == null)
                {
                    //if not, employ the safety fallback - take the highest available one
                    if (loPrintPicture.Revisions.Count > 0)
                    {
                        loFormatInfo.fCurrentRecordPrintPicRev = loPrintPicture.Revisions[loPrintPicture.Revisions.Count - 1];
                    }
                }





            }

            // did we find a print picture?
            if (loFormatInfo.fCurrentRecordPrintPicRev != null)
            {
                // then we'll need to get some info about the paper we're emulating
                //loFormatInfo.fPaperInfo = new HandheldPaperInfo(loFormatInfo.fCurrentRecordPrintPicRev.Name, this.fClientDef.Client);
            }

            // get the collection of non-printed fields
            //InitializeNonPrintedFieldCollection(loFormatInfo);


            //// determine what our date/time masks will be
            //CultureDisplayFormatLogic oneFormatter = new CultureDisplayFormatLogic();
            //CultureDisplayFormattingTableInfo oneFormatInfo = oneFormatter.ConstructFormattingTableInfoForIssueStruct(dsDataSetStructInfo.fIssStruct);

            //loFormatInfo.fStructDateMask = oneFormatInfo.fStructDateMask;
            //loFormatInfo.fStructTimeMask = oneFormatInfo.fStructTimeMask;


            // generate a "fingerprint" for this formatting info so we can match it up for other records
            loFormatInfo.fFormatRecordFingerprint = GenerateFormattingFingerprint(iDataTableName, loFormatInfo.fTableRevNum, loFormatInfo.fFormRevName, loFormatInfo.fFormRevNum);

            // add this one to the list so others might use it
            //fFormattingTables.Add(loFormatInfo);

            // return the reference for quick access
            return loFormatInfo;
        }


        /// <summary>
        /// Resolve internal formatting table references based on the FORMREV for passed row
        /// The passed row should be from the MAIN TABLE of the record of interest
        /// Locates existing FormatInfo or creates new as needed
        /// </summary>
        private TFormattingTableInfo GenerateFormatInfoForDataRow(TDataSetStructInfo dsStructInfo, DataRow iDataRow)
        {
            // what is the fingerprint for this one?
            string loFormRevName = "";
            int loTableRevNum = 0;
            int loFormRevNum = 0;
            string loFormatFingerprint = GetFormattingTableFingerprintForDataRow(dsStructInfo, iDataRow, ref loTableRevNum, ref loFormRevName, ref loFormRevNum);

            // already have one to use? find by fingerprint
            TFormatInfoFingerprintFindPredicate loPredicate = new TFormatInfoFingerprintFindPredicate(loFormatFingerprint);
            TFormattingTableInfo loFormatInfo = fFormattingTables.Find(loPredicate.CompareByFingerprint);
            //TFormattingTableInfo loFormatInfo = null;


            // not found? gotta make one
            //if (loFormatInfo == null)
            {
                loFormatInfo = ConstructFormattingTableInfo(dsStructInfo, iDataRow.Table.TableName, loTableRevNum, loFormRevName, loFormRevNum);
            }

            // return it
            return loFormatInfo;

        }


    }
}